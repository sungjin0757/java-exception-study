## Item 69. 예외는 진짜 예외 강황에만 사용하라

***

**Terrible Code**

```java
try{
    int i=0;
    while(true){
        range[i++].climb();
        }
}catch(ArrayIndexOutOfBoundsException e){
    
}
```

이 코드는 무한 루프를 돌다가, `ArrayIndexOutOfBoundsExcetpion`이 발생했을 때, 끝을 
내는 코드입니다.

이런 코드를 사용한 이유는, 잘못된 추론을 근거로 성능을 높이기 위해서 사용한 것입니다.

JVM은 배열에 접근할 때 마다 경계를 넘지 않는지 검사하는데, 일반적인 반복문도 배열 경계에 도달하면 종료합니다.
따라서, 이 검사를 반복문에도 명시하면 같은 일이 중복되므로 하나를 생략한 것입니다.

**Wrong Inference**
1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼
빠르게 만들어야 할 동기가 약하다.
2. try-catch 블록안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
3. 배열을 순회하는 표준 관용구는 앞서 작성한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해준다.

이와같은 잘못된 추론과 결과로 인해, 실항은 예외를 사용한 쪽이 표준 관용구 보다 훨씬 느리게 됩니다.

또한, 만일 반복문 앞에 버그가 숨어 있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게 할 수도 있습니다.

**즉, 예외는 오직 예외 상황에서만 써야 합니다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다는 것을 뜻합니다.**

이 원칙은 `API` 설계에도 적용됩니다.

**잘 설계된 `API`라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없도록 해야합니다.**

특정 상태에서만 호출할 수 있는 '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 적용해야합니다.
예를 들면, 상태 의존 메서드로는 `next()` 상태 검사 메서드로는 `hasNext()` 를 들 수 있습니다.

만일, 이와 같은 메서드를 `API` 가 제공하지 않는 다면,
위의 **Terrible Code**와 같은 일이 초래될 수도 있습니다.

상태 검사 메서드 대신 사용할 수 있는 선택지도 있습니다. 올바르지 않은 상태 일 때 빈 옵셔널 혹은 null 같은 특수한 값을 반환하는 방법입니다.

**상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침**

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용합니다.
상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문입니다.
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정값을 선택합니다.
3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있습니다. 더욱 가독성이 좋고, 디버깅하기 쉽기 때문입니다.
