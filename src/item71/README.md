## Item 71. 필요 없는 검사 예외 사용은 피하라
***

결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 
처리하여 안정성을 높여줍니다.

물론, 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 `API`가 됩니다.

검사 예외와 비검사 예외 중 어느 것을 선택해야 할지는 프로그래머가 그 예외를 어떻게 다룰지 생각해보면 알 수 있습니다.

다음의 코드를 살펴보도록 합시다.

```java
} catch(TheCheckedException e){
    throw new AssertionError();
}
```

```java
} catch(ThechecedException e){
    e.printStackTrace();
    System.exit(1);
}
```

이러한 방법은 최선이 아닙니다. 효율적으로 잡아서 처리하라고한 `API`의 의도를 효율적으로 이행하지 않았기 때문입니다.

이 처럼, 검사 예외를 제대로 잡을 수 없는 경우는 비검사 예외를 사용하여야 합니다.

또한, 메소드가 단 하나만의 검사 예외를 던지는 경우는 프로그래머에게 더욱 부담을 안겨줍니다.
왜냐하면, 이미 다른 검사 예외도 던지는 상황이라면 catch를 추가해서 잡으면 되지만, 단 하나 뿐을 위해 블록을 추가하고, 스트림에서
사용이 불가능하는 등 작업이 더 필요하게 되기 때문입니다.

**검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것입니다.**

**또 다른 방법으로, 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있습니다.**
***

```java
try{
    obj.action(args);
} catch(TheChecedException e){
        ...// 예외 상황을 대처한다.
}
```

**상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후**
```java
if (obh.actionPermitted(args)){
    obj.action(args);
} else{
        ... // 예외 상황에 대처한다.
}
```

물론 이와 같은 상황에서도 **Item69**에서 말했던 다중 스레드로부터 안전하지 않은 상황에서는 이와 같은 리팩터링이
올바르지 않을 수 있습니다.

그렇지만서도 쓸데 없는 검사 예외를 던지는 것보다 더욱 유연한 `API`를 제공할 수 있습니다.